[{"/mnt/6a2df63b-8e67-4d88-b026-747472705871/GraphLabs/Graph.MyModule/graph.graph_by_matrix_adjacency/src/index.tsx":"1","/mnt/6a2df63b-8e67-4d88-b026-747472705871/GraphLabs/Graph.MyModule/graph.graph_by_matrix_adjacency/src/reportWebVitals.ts":"2","/mnt/6a2df63b-8e67-4d88-b026-747472705871/GraphLabs/Graph.MyModule/graph.graph_by_matrix_adjacency/src/App.tsx":"3"},{"size":548,"mtime":1617528430335,"results":"4","hashOfConfig":"5"},{"size":425,"mtime":1617528001937,"results":"6","hashOfConfig":"5"},{"size":9189,"mtime":1621012754908,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"q4ge36",{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"12","messages":"13","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},"/mnt/6a2df63b-8e67-4d88-b026-747472705871/GraphLabs/Graph.MyModule/graph.graph_by_matrix_adjacency/src/index.tsx",[],"/mnt/6a2df63b-8e67-4d88-b026-747472705871/GraphLabs/Graph.MyModule/graph.graph_by_matrix_adjacency/src/reportWebVitals.ts",[],"/mnt/6a2df63b-8e67-4d88-b026-747472705871/GraphLabs/Graph.MyModule/graph.graph_by_matrix_adjacency/src/App.tsx",["15","16","17","18","19","20","21"],"import React, {SFC} from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport {\n    adapter,\n    graphModel,\n    GraphVisualizer,\n    IGraphView,\n    store,\n    Template,\n    Toolbar,\n    ToolButtonList\n} from \"graphlabs.core.template\";\nimport {IVertex,IGraph, IEdge, GraphGenerator, Graph, Vertex, Edge } from 'graphlabs.core.graphs';\n\nimport {Matrix,  } from 'graphlabs.core.lib';\nimport {rename} from \"fs\";\n\n\n\n\nclass App extends Template\n{\n    task_part =1;\n    chekc_count=0; // количество проверок\n    graph: IGraph<IVertex, IEdge> = GraphGenerator.generate(0);  // граф студента\n //   matrix: number [][] = [[0, 1, 0, 1],\n //                           [1,0, 1,1],\n //                           [0,1,0,1],\n //                           [1,1,1,0]]; //матрицв тиз варианта\n    matrix:number [][] = this.get_matrix_by_variant();\n\n\n    constructor(props:{})\n    {\n\n        super(props);\n        this.getArea = this.getArea.bind(this);\n        this.calculate = this.calculate.bind(this);\n\n\n    }\n\n\n\n\n\n    protected getArea(): React.SFC<{}>\n    {\n        //this.graph = this.empty_graph();\n       //  this.graph = GraphGenerator.generate(0);\n       // this.graph = this.graph_by_variant();\n       this.matrix = this.get_matrix_by_variant();\n\n        return () => <GraphVisualizer\n         //   graph = {graphModel} //вот здесь не генерится\n         //   graph={this.graph}\n            graph = { GraphGenerator.generate(0)}\n            adapterType={'writable'}\n            incidentEdges={false}\n            weightedEdges={false}\n            namedEdges={true}\n        />;\n\n    }\n\n\t\t\t// написать тоже такую фигню для матрицы это и есть проблема \n\t\t\t\n/*    graph_by_variant():IGraph<IVertex, IEdge>{\n        const data = sessionStorage.getItem('variant');\n        let graph: IGraph<IVertex, IEdge> = new Graph() as unknown as IGraph<IVertex, IEdge>;\n        let objectData;\n        try {\n            objectData = JSON.parse(data || 'null');\n            console.log('The variant is successfully parsed');\n        } catch (err) {\n            console.log('Error while JSON parsing');\n        }\n        console.log(this.graphManager(objectData.data[0].value));\n        if (data) {\n            graph = this.graphManager(objectData.data[0].value);\n            console.log('The graph is successfully built from the variant');\n        }\n        return graph;\n    }\n*/\n\n    get_matrix_by_variant():number[][]\n    {\n        const data = sessionStorage.getItem('variant');\n        let matrix:number[][] = [];\n        let objectData;\n        try\n        {\n            objectData = JSON.parse(data || 'null');\n            console.log('The variant is successfully parsed');\n        }\n        catch(err)\n        {\n            console.log('Error while JSON parsing');\n        }\n        console.log(this.matrixManager(objectData.data[0].value));\n        if(data)\n        {\n            matrix=this.matrixManager(objectData.data[0].value);\n            console.log('The matrix is successfully built from the variant');\n        }\n\n        return matrix;\n    }\n\n    getTaskToolbar()\n    {\n        console.log(\"toolbar\");\n        Toolbar.prototype.getButtonList = () => {\n            function beforeComplete(this: App):  Promise<{ success: boolean; fee: number }> {\n                return new Promise((resolve => {\n                    resolve(this.calculate());\n                }));\n            }\n            ToolButtonList.prototype.beforeComplete = beforeComplete.bind(this);\n            ToolButtonList.prototype.help = () =>\n                'В данном задании необходимо построить граф по данной матрице смежности';\n\n\n            return ToolButtonList;\n        };\n        return Toolbar;\n    }\n\n\n//для разработки\n    private empty_graph():IGraph<IVertex, IEdge>{\n        const data = sessionStorage.getItem('variant');\n        let graph: IGraph<IVertex, IEdge> = new Graph() as unknown as IGraph<IVertex, IEdge>;\n        let objectData;\n        try {\n            objectData = JSON.parse(data || 'null');\n        } catch (err) {\n            console.log('Error while JSON parsing');\n        }\n        if (objectData && objectData.data[0] && objectData.data[0].type === 'graph') {\n            graph = this.graphManager(objectData.data[0].value);\n            const vertices = objectData.data[0].value.graph.vertices;\n            const edges  = objectData.data[0].value.graph.edges;\n            vertices.forEach((v: any) => {\n                graph.addVertex(new Vertex(v));\n            });\n            edges.forEach((e: any) => {\n                if (e.name) {\n                    graph.addEdge(new Edge(graph.getVertex(e.source)[0], graph.getVertex(e.target)[0], e.name[0]));\n                } else {\n                    graph.addEdge(new Edge(graph.getVertex(e.source)[0], graph.getVertex(e.target)[0],Math.round(Math.random()*10).toString() ));\n                }\n            });\n        }\n        return graph;\n    }\n\n\n    private get_matrixAdjacency_byGraph(student_graph:IGraph<IVertex, IEdge>): number[][]\n    {\n        let result: number[][]=[];\n        const dim: number = student_graph.vertices.length;\n\n        for (let i: number=0; i<dim;i++)\n        {\n            result.push([]);\n            for (let j: number = 0; j<dim;j++)\n            {\n                if (student_graph.vertices[i].isAdjacent(student_graph, student_graph.vertices[j])) {\n                    result[i].push(1);\n\n                } else {\n                    result[i].push(0);\n                }\n\n            }\n        }\n\n\n        return result;\n    }\n\n\n    private graph_check(): boolean\n    {\n        let flag: boolean = true;\n        let matrixAdj_by_student_graph:number[][] = this.get_matrixAdjacency_byGraph(this.graph);\n        let i:number =0;\n        let j:number =0;\n\n        if(this.graph.vertices.length===this.matrix.length)\n        {\n            while (flag && i<this.graph.vertices.length)\n            {\n                    if(matrixAdj_by_student_graph[i][i]===0)\n                    {\n                        j=i+1;\n                        while (flag && j < this.graph.vertices.length)\n                        {\n                            if(matrixAdj_by_student_graph[i][j]!==matrixAdj_by_student_graph[j][i] || matrixAdj_by_student_graph[i][j] !== this.matrix[i][j])\n                            {\n                                flag=false;\n                                this.chekc_count+=1;\n                            }\n                            j+=1;\n                        }\n                    }\n                    else\n                    {\n                        flag=false;\n                        this.chekc_count+=1;\n                    }\n                    i+=1;\n\n            }\n        }\n        else\n        {\n            flag=false;\n            this.chekc_count+=1;\n        }\n\n\n\n        return flag;\n    }\n\n\n    // @ts-ignore\n    task(): FunctionComponent<{}> {\n        console.log(\"task\");\n        if (this.task_part === 1) {\n            console.log(this.matrix);\n            return () =>\n                <div>\n                    <form>\n                        <span> Матрица смежности </span>\n                        <br> </br>\n                        <Matrix rows={this.matrix.length}\n                                columns={this.matrix.length}\n                                readonly={true}\n                                defaultValues={this.matrix}/>\n                        <br> </br>\n                        <button type=\"button\"\n                                onClick={() => {\n                                    this.task_part += 1;\n                                    this.forceUpdate();\n                                }}> Проверить граф\n                        </button>\n                    </form>\n                </div>\n        }\n        if (this.task_part === 2) {\n            if (this.graph_check())\n                return () => (\n                    <div>\n                        <form>\n                            <span> Все правильно. Нажмите зеленую галочку для подсчета результата</span>\n                        </form>\n                    </div>\n                );\n            else {\n                return () => (\n                    <div>\n                        <form>\n                            <span> Есть ошибки</span>\n                            <button type=\"button\"\n                                    onClick={() => {\n                                        this.task_part = 1;\n                                        this.forceUpdate();\n                                    }}> Исправить ошибки\n                            </button>\n                        </form>\n                    </div>\n                );\n            }\n        }\n\n\n    }\n\n\n\n\n    private calculate()\n    {\n        let  res:number = (this.graph.vertices.length+this.graph.edges.length)* this.chekc_count;\n        return {success: res===0, fee: res}\n    }\n}\n\nexport default App;\n",{"ruleId":"22","severity":1,"message":"23","line":1,"column":16,"nodeType":"24","messageId":"25","endLine":1,"endColumn":19},{"ruleId":"22","severity":1,"message":"26","line":2,"column":8,"nodeType":"24","messageId":"25","endLine":2,"endColumn":12},{"ruleId":"22","severity":1,"message":"27","line":5,"column":5,"nodeType":"24","messageId":"25","endLine":5,"endColumn":12},{"ruleId":"22","severity":1,"message":"28","line":6,"column":5,"nodeType":"24","messageId":"25","endLine":6,"endColumn":15},{"ruleId":"22","severity":1,"message":"29","line":8,"column":5,"nodeType":"24","messageId":"25","endLine":8,"endColumn":15},{"ruleId":"22","severity":1,"message":"30","line":9,"column":5,"nodeType":"24","messageId":"25","endLine":9,"endColumn":10},{"ruleId":"22","severity":1,"message":"31","line":17,"column":9,"nodeType":"24","messageId":"25","endLine":17,"endColumn":15},"@typescript-eslint/no-unused-vars","'SFC' is defined but never used.","Identifier","unusedVar","'logo' is defined but never used.","'adapter' is defined but never used.","'graphModel' is defined but never used.","'IGraphView' is defined but never used.","'store' is defined but never used.","'rename' is defined but never used."]